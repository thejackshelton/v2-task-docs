---
title: Tasks
description: This is a learn section. It is not specific to specific hooks. We will have a reference section for each hook later.
---

import serverRack from '~/assets/server-rack.webp'
import theClient from '~/assets/the-client.webp'

# Tasks

Tasks are how your application responds to change.

When you're building an application, things change constantly. Users type in inputs, data is fetched from different sources, timers fire, and state needs to be updated. Tasks help you manage all of these changes by:

1. **Watching for changes** - Tasks track the state you care about
2. **Running your code** - When tracked state changes, your task runs again
3. **Cleaning up** - Tasks clean up previous code before running again

> What makes Qwik's task system special is that you can choose where each function runs - on the server, in the browser, or both - while Qwik handles all the efficient state management between environments.

## Tasks Run Based on Environment

Tasks *initially* run in the same place where your component is created. 

```tsx
  export default component$(() => {
    console.log("I'm inside the component boundary. I run once when rendered!")

    useTask$(() => {
      console.log("Nothing special here, so I run once based on the environment!")
    })

    {...}
  })
```

> The following examples cover `useTask$`, but the same principles apply to `useComputed$`, `useResource$` and other functions called within a component, with the exception of `useVisibleTask$`.

### Created in the Browser

When a component is created from user interaction (like clicking a button), it runs in the browser:

<Showcase name="task-conditional" />

## Environment rendering strategies

Your app can run entirely in the browser (CSR) or start on a server (SSR/SSG) - this choice affects where your code runs.

### How can I know where my code is running?

Without having to be an expert in rendering strategies, you can inspect the Qwik container element to understand where your code is running.

Every Qwik application is wrapped in a container element (usually the `<html>` element) that provides information about how and where the code is running. You can inspect this container in your browser's DevTools to understand the execution environment.

### Finding the Container

Look for an element with a `q:container` attribute - this is your Qwik container. It will typically look something like this:

```html
<html q:container="paused" 
      q:version="2.0.0" 
      q:render="ssr" 
      q:base="/build/">
```

- `dom` - This part of the page was client side rendered
- `ssr` - This part of the page was server side rendered
- `static-ssr` - This part of the page was statically generated

> In dev mode, the value of the `q:render` attribute will have an appended `-dev` suffix.

### Client Side Rendering (CSR)

When a visitor of your site first reaches a page, and that page uses [Client side rendering (CSR)](https://www.youtube.com/watch?v=4-Lel1oaV7M), the task and application code will **always** run in the browser.

<img 
  src={theClient} 
  alt="The Client" 
  class="max-w-50 mix-blend-luminosity rounded-full border-2 border-white mx-auto" 
/>

Even if this task function runs again, it will **always** run in the browser.

```tsx
useTask$(() => {
  // Always browser code
})
```

> CSR can be enabled by setting `csr: true` in the `qwikVite` plugin options.

### Server Side Rendering (SSR) and Static Site Generation (SSG)

<img src={serverRack} alt="Server Rack" class="border-2 border-gray-50 max-w-50 object-cover rounded-full mx-auto" />

When a user visits a page that uses [SSR](https://www.youtube.com/watch?v=0bvo6UKkNDA) or [SSG](https://www.youtube.com/watch?v=1zhT23VDVDc), the server prepares everything - including running your tasks - before sending the HTML to the browser. This is a key feature of Qwik's resumability - code that runs on the server doesn't need to run again in the browser.

```tsx
export default component$(() => {
  useTask$(() => {
    // During initial page load:
    //   ✅ Runs on the server
    //   ❌ Doesn't run in browser
    //   ✅ Runs before rendering
    //   ✅ Can be async
    //   ✅ Blocks rendering until complete
  });
  
  return <div>Hello</div>;
});
```

#### Benefits of Server Execution

Running code on the server when possible (like data fetching or heavy computations) gives you several key benefits:

1. **Better Performance** - Servers are typically more powerful than user devices
2. **Smaller Bundle Size** - Users don't need to download code that already ran on the server
3. **Improved SEO** - Search engines see the fully rendered content
4. **Faster Initial Page Load** - Content is ready when HTML arrives

<Showcase name="task-server" />

#### Execute code when users care

Running code on the server when possible (like data fetching or heavy computations) gives you two key benefits:
1. Better performance - servers are typically more powerful than user devices
2. Smaller bundle size - users don't need to download code that already ran on the server

<Showcase name="task-server" />

#### Navigating with `<Link />` (Hybrid Rendering)

Using Qwik Router's `<Link />` component lets you switch between pages without a full page reload. When you click the Link component, any new tasks will run in the browser:

```tsx
export default component$(() => {
  return (
    <>
      <a href="/blog">
        Blog (Static Site Generated) after click
      </a>

      <Link href="/dashboard">
        Dashboard (Client-Side Rendered) after click
      </Link>
    </>
  );
});
```

However, in the context of a server rendered application, refreshing the dashboard page will run the task code on the server. The next section covers how to ensure your code only runs in the intended environment.

## Ensure your code *only* runs in the intended environment

Qwik provides two ways to ensure your code only runs in the intended environment:

1. `isServer` - Check if the code is running on the **server**
2. `isBrowser` - Check if the code is running on the **browser**

```tsx
import { isBrowser, isServer } from '@qwik.dev/core';

export default component$(() => {
  useTask$(() => {
    if (isServer) {
      // code here will ONLY run on the server
    }

    if (isBrowser) {
      // code here will ONLY run on the browser
    }
  })

  {...}
})
```

Alternatively, you could early return based on the environment:

```tsx
useTask$(() => {
  // server and browser code can go here

  if (isServer) return;

  // browser only code can go here
})
```

## When tasks run

Now that you know how to check *where* your code is running, it's important to know *when* your code runs.

Tasks run before the JSX has been rendered. Taking a look at our earlier example, we can see that the task changed the signal value before the page was server rendered:

<Showcase name="task-server" />

> An exception to this rule is `useVisibleTask$` - the callback function passed to the hook runs after the JSX has been rendered.

### Tasks run in order

Tasks run sequentially in the order they are defined - like following steps in a recipe. Just as you can't frost a cake before baking it, tasks will execute one after another in the order you write them.

<Showcase name="task-order" />

## The Multi-Source Counter

Consider a character counter that needs to stay updated when text changes from **any source**. This example shows how Tasks help manage:
- Input validation
- API calls
- Cleanup operations

<Showcase name="task-counter" />
